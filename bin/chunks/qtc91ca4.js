import*as A from"crypto";var G=A&&typeof A==="object"&&"webcrypto"in A?A.webcrypto:A&&typeof A==="object"&&("randomBytes"in A)?A:void 0;function K(q){if(!Number.isSafeInteger(q)||q<0)throw new Error("positive integer expected, got "+q)}function O(q){return q instanceof Uint8Array||ArrayBuffer.isView(q)&&q.constructor.name==="Uint8Array"}function I(q,...v){if(!O(q))throw new Error("Uint8Array expected");if(v.length>0&&!v.includes(q.length))throw new Error("Uint8Array expected of length "+v+", got length="+q.length)}function Y(q){if(typeof q!=="function"||typeof q.create!=="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");K(q.outputLen),K(q.blockLen)}function Z(q,v=!0){if(q.destroyed)throw new Error("Hash instance has been destroyed");if(v&&q.finished)throw new Error("Hash#digest() has already been called")}function $(q,v){I(q);let D=v.outputLen;if(q.length<D)throw new Error("digestInto() expects output buffer of length at least "+D)}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function S(q){return new Uint32Array(q.buffer,q.byteOffset,Math.floor(q.byteLength/4))}function _(q){return new DataView(q.buffer,q.byteOffset,q.byteLength)}function M(q,v){return q<<32-v|q>>>v}var R=(()=>new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68)();function P(q){return q<<24&4278190080|q<<8&16711680|q>>>8&65280|q>>>24&255}function U(q){for(let v=0;v<q.length;v++)q[v]=P(q[v])}function Q(q){if(typeof q!=="string")throw new Error("utf8ToBytes expected string, got "+typeof q);return new Uint8Array(new TextEncoder().encode(q))}function V(q){if(typeof q==="string")q=Q(q);return I(q),q}function j(...q){let v=0;for(let z=0;z<q.length;z++){let H=q[z];I(H),v+=H.length}let D=new Uint8Array(v);for(let z=0,H=0;z<q.length;z++){let J=q[z];D.set(J,H),H+=J.length}return D}class W{clone(){return this._cloneInto()}}function T(q){let v=(z)=>q().update(V(z)).digest(),D=q();return v.outputLen=D.outputLen,v.blockLen=D.blockLen,v.create=()=>q(),v}function k(q=32){if(G&&typeof G.getRandomValues==="function")return G.getRandomValues(new Uint8Array(q));if(G&&typeof G.randomBytes==="function")return G.randomBytes(q);throw new Error("crypto.getRandomValues must be defined")}
export{K as pc,I as qc,Y as rc,Z as sc,$ as tc,S as uc,_ as vc,M as wc,R as xc,U as yc,V as zc,j as Ac,W as Bc,T as Cc,k as Dc};

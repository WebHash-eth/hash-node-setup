// @bun
import{Ac as l$,Bc as g0,Cc as B$,Dc as r0,qc as S$,rc as k$,sc as C0,tc as H$,vc as f0,wc as a,zc as _0}from"./qtc91ca4.js";import{Fc as YJ}from"./xkwf7zm3.js";function QJ($,G,J,Q){if(typeof $.setBigUint64==="function")return $.setBigUint64(G,J,Q);let q=BigInt(32),Y=BigInt(4294967295),M=Number(J>>q&Y),K=Number(J&Y),X=Q?4:0,A=Q?0:4;$.setUint32(G+X,M,Q),$.setUint32(G+A,K,Q)}function T$($,G,J){return $&G^~$&J}function L$($,G,J){return $&G^$&J^G&J}class t0 extends g0{constructor($,G,J,Q){super();this.blockLen=$,this.outputLen=G,this.padOffset=J,this.isLE=Q,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array($),this.view=f0(this.buffer)}update($){C0(this);let{view:G,buffer:J,blockLen:Q}=this;$=_0($);let q=$.length;for(let Y=0;Y<q;){let M=Math.min(Q-this.pos,q-Y);if(M===Q){let K=f0($);for(;Q<=q-Y;Y+=Q)this.process(K,Y);continue}if(J.set($.subarray(Y,Y+M),this.pos),this.pos+=M,Y+=M,this.pos===Q)this.process(G,0),this.pos=0}return this.length+=$.length,this.roundClean(),this}digestInto($){C0(this),H$($,this),this.finished=!0;let{buffer:G,view:J,blockLen:Q,isLE:q}=this,{pos:Y}=this;if(G[Y++]=128,this.buffer.subarray(Y).fill(0),this.padOffset>Q-Y)this.process(J,0),Y=0;for(let Z=Y;Z<Q;Z++)G[Z]=0;QJ(J,Q-8,BigInt(this.length*8),q),this.process(J,0);let M=f0($),K=this.outputLen;if(K%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let X=K/4,A=this.get();if(X>A.length)throw new Error("_sha2: outputLen bigger than state");for(let Z=0;Z<X;Z++)M.setUint32(4*Z,A[Z],q)}digest(){let{buffer:$,outputLen:G}=this;this.digestInto($);let J=$.slice(0,G);return this.destroy(),J}_cloneInto($){$||($=new this.constructor),$.set(...this.get());let{blockLen:G,buffer:J,length:Q,finished:q,destroyed:Y,pos:M}=this;if($.length=Q,$.pos=M,$.finished=q,$.destroyed=Y,Q%G)$.buffer.set(J);return $}}var qJ=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),q0=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Y0=new Uint32Array(64);class R$ extends t0{constructor(){super(64,32,8,!1);this.A=q0[0]|0,this.B=q0[1]|0,this.C=q0[2]|0,this.D=q0[3]|0,this.E=q0[4]|0,this.F=q0[5]|0,this.G=q0[6]|0,this.H=q0[7]|0}get(){let{A:$,B:G,C:J,D:Q,E:q,F:Y,G:M,H:K}=this;return[$,G,J,Q,q,Y,M,K]}set($,G,J,Q,q,Y,M,K){this.A=$|0,this.B=G|0,this.C=J|0,this.D=Q|0,this.E=q|0,this.F=Y|0,this.G=M|0,this.H=K|0}process($,G){for(let Z=0;Z<16;Z++,G+=4)Y0[Z]=$.getUint32(G,!1);for(let Z=16;Z<64;Z++){let N=Y0[Z-15],U=Y0[Z-2],W=a(N,7)^a(N,18)^N>>>3,T=a(U,17)^a(U,19)^U>>>10;Y0[Z]=T+Y0[Z-7]+W+Y0[Z-16]|0}let{A:J,B:Q,C:q,D:Y,E:M,F:K,G:X,H:A}=this;for(let Z=0;Z<64;Z++){let N=a(M,6)^a(M,11)^a(M,25),U=A+N+T$(M,K,X)+qJ[Z]+Y0[Z]|0,T=(a(J,2)^a(J,13)^a(J,22))+L$(J,Q,q)|0;A=X,X=K,K=M,M=Y+U|0,Y=q,q=Q,Q=J,J=U+T|0}J=J+this.A|0,Q=Q+this.B|0,q=q+this.C|0,Y=Y+this.D|0,M=M+this.E|0,K=K+this.F|0,X=X+this.G|0,A=A+this.H|0,this.set(J,Q,q,Y,M,K,X,A)}roundClean(){Y0.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}var B0=B$(()=>new R$);class e0 extends g0{constructor($,G){super();this.finished=!1,this.destroyed=!1,k$($);let J=_0(G);if(this.iHash=$.create(),typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let Q=this.blockLen,q=new Uint8Array(Q);q.set(J.length>Q?$.create().update(J).digest():J);for(let Y=0;Y<q.length;Y++)q[Y]^=54;this.iHash.update(q),this.oHash=$.create();for(let Y=0;Y<q.length;Y++)q[Y]^=106;this.oHash.update(q),q.fill(0)}update($){return C0(this),this.iHash.update($),this}digestInto($){C0(this),S$($,this.outputLen),this.finished=!0,this.iHash.digestInto($),this.oHash.update($),this.oHash.digestInto($),this.destroy()}digest(){let $=new Uint8Array(this.oHash.outputLen);return this.digestInto($),$}_cloneInto($){$||($=Object.create(Object.getPrototypeOf(this),{}));let{oHash:G,iHash:J,finished:Q,destroyed:q,blockLen:Y,outputLen:M}=this;return $=$,$.finished=Q,$.destroyed=q,$.blockLen=Y,$.outputLen=M,$.oHash=G._cloneInto($.oHash),$.iHash=J._cloneInto($.iHash),$}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}var $$=($,G,J)=>new e0($,G).update(J).digest();$$.create=($,G)=>new e0($,G);var X$={};YJ(X$,{validateObject:()=>$0,utf8ToBytes:()=>R0,numberToVarBytesBE:()=>KJ,numberToHexUnpadded:()=>N0,numberToBytesLE:()=>h0,numberToBytesBE:()=>p,notImplemented:()=>UJ,memoized:()=>c0,isBytes:()=>X0,inRange:()=>M0,hexToNumber:()=>Q$,hexToBytes:()=>V0,equalBytes:()=>IJ,ensureBytes:()=>y,createHmacDrbg:()=>Y$,concatBytes:()=>c,bytesToNumberLE:()=>y0,bytesToNumberBE:()=>u,bytesToHex:()=>j0,bitSet:()=>ZJ,bitMask:()=>S0,bitLen:()=>q$,bitGet:()=>AJ,abytes:()=>i,abool:()=>U0,aInRange:()=>e});/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var b0=BigInt(0),v0=BigInt(1),XJ=BigInt(2);function X0($){return $ instanceof Uint8Array||ArrayBuffer.isView($)&&$.constructor.name==="Uint8Array"}function i($){if(!X0($))throw new Error("Uint8Array expected")}function U0($,G){if(typeof G!=="boolean")throw new Error($+" boolean expected, got "+G)}var MJ=Array.from({length:256},($,G)=>G.toString(16).padStart(2,"0"));function j0($){i($);let G="";for(let J=0;J<$.length;J++)G+=MJ[$[J]];return G}function N0($){let G=$.toString(16);return G.length&1?"0"+G:G}function Q$($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);return $===""?b0:BigInt("0x"+$)}var J0={_0:48,_9:57,A:65,F:70,a:97,f:102};function x$($){if($>=J0._0&&$<=J0._9)return $-J0._0;if($>=J0.A&&$<=J0.F)return $-(J0.A-10);if($>=J0.a&&$<=J0.f)return $-(J0.a-10);return}function V0($){if(typeof $!=="string")throw new Error("hex string expected, got "+typeof $);let G=$.length,J=G/2;if(G%2)throw new Error("hex string expected, got unpadded hex of length "+G);let Q=new Uint8Array(J);for(let q=0,Y=0;q<J;q++,Y+=2){let M=x$($.charCodeAt(Y)),K=x$($.charCodeAt(Y+1));if(M===void 0||K===void 0){let X=$[Y]+$[Y+1];throw new Error('hex string expected, got non-hex character "'+X+'" at index '+Y)}Q[q]=M*16+K}return Q}function u($){return Q$(j0($))}function y0($){return i($),Q$(j0(Uint8Array.from($).reverse()))}function p($,G){return V0($.toString(16).padStart(G*2,"0"))}function h0($,G){return p($,G).reverse()}function KJ($){return V0(N0($))}function y($,G,J){let Q;if(typeof G==="string")try{Q=V0(G)}catch(Y){throw new Error($+" must be hex string or Uint8Array, cause: "+Y)}else if(X0(G))Q=Uint8Array.from(G);else throw new Error($+" must be hex string or Uint8Array");let q=Q.length;if(typeof J==="number"&&q!==J)throw new Error($+" of length "+J+" expected, got "+q);return Q}function c(...$){let G=0;for(let Q=0;Q<$.length;Q++){let q=$[Q];i(q),G+=q.length}let J=new Uint8Array(G);for(let Q=0,q=0;Q<$.length;Q++){let Y=$[Q];J.set(Y,q),q+=Y.length}return J}function IJ($,G){if($.length!==G.length)return!1;let J=0;for(let Q=0;Q<$.length;Q++)J|=$[Q]^G[Q];return J===0}function R0($){if(typeof $!=="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode($))}var J$=($)=>typeof $==="bigint"&&b0<=$;function M0($,G,J){return J$($)&&J$(G)&&J$(J)&&G<=$&&$<J}function e($,G,J,Q){if(!M0(G,J,Q))throw new Error("expected valid "+$+": "+J+" <= n < "+Q+", got "+G)}function q$($){let G;for(G=0;$>b0;$>>=v0,G+=1);return G}function AJ($,G){return $>>BigInt(G)&v0}function ZJ($,G,J){return $|(J?v0:b0)<<BigInt(G)}var S0=($)=>(XJ<<BigInt($-1))-v0,G$=($)=>new Uint8Array($),w$=($)=>Uint8Array.from($);function Y$($,G,J){if(typeof $!=="number"||$<2)throw new Error("hashLen must be a number");if(typeof G!=="number"||G<2)throw new Error("qByteLen must be a number");if(typeof J!=="function")throw new Error("hmacFn must be a function");let Q=G$($),q=G$($),Y=0,M=()=>{Q.fill(1),q.fill(0),Y=0},K=(...N)=>J(q,Q,...N),X=(N=G$())=>{if(q=K(w$([0]),N),Q=K(),N.length===0)return;q=K(w$([1]),N),Q=K()},A=()=>{if(Y++>=1000)throw new Error("drbg: tried 1000 values");let N=0,U=[];while(N<G){Q=K();let W=Q.slice();U.push(W),N+=Q.length}return c(...U)};return(N,U)=>{M(),X(N);let W=void 0;while(!(W=U(A())))X();return M(),W}}var zJ={bigint:($)=>typeof $==="bigint",function:($)=>typeof $==="function",boolean:($)=>typeof $==="boolean",string:($)=>typeof $==="string",stringOrUint8Array:($)=>typeof $==="string"||X0($),isSafeInteger:($)=>Number.isSafeInteger($),array:($)=>Array.isArray($),field:($,G)=>G.Fp.isValid($),hash:($)=>typeof $==="function"&&Number.isSafeInteger($.outputLen)};function $0($,G,J={}){let Q=(q,Y,M)=>{let K=zJ[Y];if(typeof K!=="function")throw new Error("invalid validator function");let X=$[q];if(M&&X===void 0)return;if(!K(X,$))throw new Error("param "+String(q)+" is invalid. Expected "+Y+", got "+X)};for(let[q,Y]of Object.entries(G))Q(q,Y,!1);for(let[q,Y]of Object.entries(J))Q(q,Y,!0);return $}var UJ=()=>{throw new Error("not implemented")};function c0($){let G=new WeakMap;return(J,...Q)=>{let q=G.get(J);if(q!==void 0)return q;let Y=$(J,...Q);return G.set(J,Y),Y}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var h=BigInt(0),g=BigInt(1),W0=BigInt(2),jJ=BigInt(3),M$=BigInt(4),E$=BigInt(5),P$=BigInt(8),NJ=BigInt(9),VJ=BigInt(16);function b($,G){let J=$%G;return J>=h?J:G+J}function WJ($,G,J){if(G<h)throw new Error("invalid exponent, negatives unsupported");if(J<=h)throw new Error("invalid modulus");if(J===g)return h;let Q=g;while(G>h){if(G&g)Q=Q*$%J;$=$*$%J,G>>=g}return Q}function r($,G,J){let Q=$;while(G-- >h)Q*=Q,Q%=J;return Q}function d0($,G){if($===h)throw new Error("invert: expected non-zero number");if(G<=h)throw new Error("invert: expected positive modulus, got "+G);let J=b($,G),Q=G,q=h,Y=g,M=g,K=h;while(J!==h){let A=Q/J,Z=Q%J,N=q-M*A,U=Y-K*A;Q=J,J=Z,q=M,Y=K,M=N,K=U}if(Q!==g)throw new Error("invert: does not exist");return b(q,G)}function OJ($){let G=($-g)/W0,J,Q,q;for(J=$-g,Q=0;J%W0===h;J/=W0,Q++);for(q=W0;q<$&&WJ(q,G,$)!==$-g;q++)if(q>1000)throw new Error("Cannot find square root: likely non-prime P");if(Q===1){let M=($+g)/M$;return function K(X,A){let Z=X.pow(A,M);if(!X.eql(X.sqr(Z),A))throw new Error("Cannot find square root");return Z}}let Y=(J+g)/W0;return function M(K,X){if(K.pow(X,G)===K.neg(K.ONE))throw new Error("Cannot find square root");let A=Q,Z=K.pow(K.mul(K.ONE,q),J),N=K.pow(X,Y),U=K.pow(X,J);while(!K.eql(U,K.ONE)){if(K.eql(U,K.ZERO))return K.ZERO;let W=1;for(let I=K.sqr(U);W<A;W++){if(K.eql(I,K.ONE))break;I=K.sqr(I)}let T=K.pow(Z,g<<BigInt(A-W-1));Z=K.sqr(T),N=K.mul(N,T),U=K.mul(U,Z),A=W}return N}}function DJ($){if($%M$===jJ){let G=($+g)/M$;return function J(Q,q){let Y=Q.pow(q,G);if(!Q.eql(Q.sqr(Y),q))throw new Error("Cannot find square root");return Y}}if($%P$===E$){let G=($-E$)/P$;return function J(Q,q){let Y=Q.mul(q,W0),M=Q.pow(Y,G),K=Q.mul(q,M),X=Q.mul(Q.mul(K,W0),M),A=Q.mul(K,Q.sub(X,Q.ONE));if(!Q.eql(Q.sqr(A),q))throw new Error("Cannot find square root");return A}}if($%VJ===NJ);return OJ($)}var CJ=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function F0($){let G={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},J=CJ.reduce((Q,q)=>{return Q[q]="function",Q},G);return $0($,J)}function HJ($,G,J){if(J<h)throw new Error("invalid exponent, negatives unsupported");if(J===h)return $.ONE;if(J===g)return G;let Q=$.ONE,q=G;while(J>h){if(J&g)Q=$.mul(Q,q);q=$.sqr(q),J>>=g}return Q}function TJ($,G){let J=new Array(G.length),Q=G.reduce((Y,M,K)=>{if($.is0(M))return Y;return J[K]=Y,$.mul(Y,M)},$.ONE),q=$.inv(Q);return G.reduceRight((Y,M,K)=>{if($.is0(M))return Y;return J[K]=$.mul(Y,J[K]),$.mul(Y,M)},q),J}function K$($,G){let J=G!==void 0?G:$.toString(2).length,Q=Math.ceil(J/8);return{nBitLength:J,nByteLength:Q}}function u0($,G,J=!1,Q={}){if($<=h)throw new Error("invalid field: expected ORDER > 0, got "+$);let{nBitLength:q,nByteLength:Y}=K$($,G);if(Y>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let M,K=Object.freeze({ORDER:$,isLE:J,BITS:q,BYTES:Y,MASK:S0(q),ZERO:h,ONE:g,create:(X)=>b(X,$),isValid:(X)=>{if(typeof X!=="bigint")throw new Error("invalid field element: expected bigint, got "+typeof X);return h<=X&&X<$},is0:(X)=>X===h,isOdd:(X)=>(X&g)===g,neg:(X)=>b(-X,$),eql:(X,A)=>X===A,sqr:(X)=>b(X*X,$),add:(X,A)=>b(X+A,$),sub:(X,A)=>b(X-A,$),mul:(X,A)=>b(X*A,$),pow:(X,A)=>HJ(K,X,A),div:(X,A)=>b(X*d0(A,$),$),sqrN:(X)=>X*X,addN:(X,A)=>X+A,subN:(X,A)=>X-A,mulN:(X,A)=>X*A,inv:(X)=>d0(X,$),sqrt:Q.sqrt||((X)=>{if(!M)M=DJ($);return M(K,X)}),invertBatch:(X)=>TJ(K,X),cmov:(X,A,Z)=>Z?A:X,toBytes:(X)=>J?h0(X,Y):p(X,Y),fromBytes:(X)=>{if(X.length!==Y)throw new Error("Field.fromBytes: expected "+Y+" bytes, got "+X.length);return J?y0(X):u(X)}});return Object.freeze(K)}function f$($){if(typeof $!=="bigint")throw new Error("field order must be bigint");let G=$.toString(2).length;return Math.ceil(G/8)}function I$($){let G=f$($);return G+Math.ceil(G/2)}function _$($,G,J=!1){let Q=$.length,q=f$(G),Y=I$(G);if(Q<16||Q<Y||Q>1024)throw new Error("expected "+Y+"-1024 bytes of input, got "+Q);let M=J?y0($):u($),K=b(M,G-g)+g;return J?h0(K,q):p(K,q)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var g$=BigInt(0),m0=BigInt(1);function A$($,G){let J=G.negate();return $?J:G}function b$($,G){if(!Number.isSafeInteger($)||$<=0||$>G)throw new Error("invalid window size, expected [1.."+G+"], got W="+$)}function Z$($,G){b$($,G);let J=Math.ceil(G/$)+1,Q=2**($-1);return{windows:J,windowSize:Q}}function LJ($,G){if(!Array.isArray($))throw new Error("array expected");$.forEach((J,Q)=>{if(!(J instanceof G))throw new Error("invalid point at index "+Q)})}function BJ($,G){if(!Array.isArray($))throw new Error("array of scalars expected");$.forEach((J,Q)=>{if(!G.isValid(J))throw new Error("invalid scalar at index "+Q)})}var z$=new WeakMap,v$=new WeakMap;function U$($){return v$.get($)||1}function y$($,G){return{constTimeNegate:A$,hasPrecomputes(J){return U$(J)!==1},unsafeLadder(J,Q,q=$.ZERO){let Y=J;while(Q>g$){if(Q&m0)q=q.add(Y);Y=Y.double(),Q>>=m0}return q},precomputeWindow(J,Q){let{windows:q,windowSize:Y}=Z$(Q,G),M=[],K=J,X=K;for(let A=0;A<q;A++){X=K,M.push(X);for(let Z=1;Z<Y;Z++)X=X.add(K),M.push(X);K=X.double()}return M},wNAF(J,Q,q){let{windows:Y,windowSize:M}=Z$(J,G),K=$.ZERO,X=$.BASE,A=BigInt(2**J-1),Z=2**J,N=BigInt(J);for(let U=0;U<Y;U++){let W=U*M,T=Number(q&A);if(q>>=N,T>M)T-=Z,q+=m0;let I=W,z=W+Math.abs(T)-1,O=U%2!==0,V=T<0;if(T===0)X=X.add(A$(O,Q[I]));else K=K.add(A$(V,Q[z]))}return{p:K,f:X}},wNAFUnsafe(J,Q,q,Y=$.ZERO){let{windows:M,windowSize:K}=Z$(J,G),X=BigInt(2**J-1),A=2**J,Z=BigInt(J);for(let N=0;N<M;N++){let U=N*K;if(q===g$)break;let W=Number(q&X);if(q>>=Z,W>K)W-=A,q+=m0;if(W===0)continue;let T=Q[U+Math.abs(W)-1];if(W<0)T=T.negate();Y=Y.add(T)}return Y},getPrecomputes(J,Q,q){let Y=z$.get(Q);if(!Y){if(Y=this.precomputeWindow(Q,J),J!==1)z$.set(Q,q(Y))}return Y},wNAFCached(J,Q,q){let Y=U$(J);return this.wNAF(Y,this.getPrecomputes(Y,J,q),Q)},wNAFCachedUnsafe(J,Q,q,Y){let M=U$(J);if(M===1)return this.unsafeLadder(J,Q,Y);return this.wNAFUnsafe(M,this.getPrecomputes(M,J,q),Q,Y)},setWindowSize(J,Q){b$(Q,G),v$.set(J,Q),z$.delete(J)}}}function h$($,G,J,Q){if(LJ(J,$),BJ(Q,G),J.length!==Q.length)throw new Error("arrays of points and scalars must have equal length");let q=$.ZERO,Y=q$(BigInt(J.length)),M=Y>12?Y-3:Y>4?Y-2:Y?2:1,K=(1<<M)-1,X=new Array(K+1).fill(q),A=Math.floor((G.BITS-1)/M)*M,Z=q;for(let N=A;N>=0;N-=M){X.fill(q);for(let W=0;W<Q.length;W++){let T=Q[W],I=Number(T>>BigInt(N)&BigInt(K));X[I]=X[I].add(J[W])}let U=q;for(let W=X.length-1,T=q;W>0;W--)T=T.add(X[W]),U=U.add(T);if(Z=Z.add(U),N!==0)for(let W=0;W<M;W++)Z=Z.double()}return Z}function j$($){return F0($.Fp),$0($,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...K$($.n,$.nBitLength),...$,...{p:$.Fp.ORDER}})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function c$($){if($.lowS!==void 0)U0("lowS",$.lowS);if($.prehash!==void 0)U0("prehash",$.prehash)}function RJ($){let G=j$($);$0(G,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:J,Fp:Q,a:q}=G;if(J){if(!Q.eql(q,Q.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof J!=="object"||typeof J.beta!=="bigint"||typeof J.splitScalar!=="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...G})}var{bytesToNumberBE:SJ,hexToBytes:kJ}=X$;class F$ extends Error{constructor($=""){super($)}}var G0={Err:F$,_tlv:{encode:($,G)=>{let{Err:J}=G0;if($<0||$>256)throw new J("tlv.encode: wrong tag");if(G.length&1)throw new J("tlv.encode: unpadded data");let Q=G.length/2,q=N0(Q);if(q.length/2&128)throw new J("tlv.encode: long form length too big");let Y=Q>127?N0(q.length/2|128):"";return N0($)+Y+q+G},decode($,G){let{Err:J}=G0,Q=0;if($<0||$>256)throw new J("tlv.encode: wrong tag");if(G.length<2||G[Q++]!==$)throw new J("tlv.decode: wrong tlv");let q=G[Q++],Y=!!(q&128),M=0;if(!Y)M=q;else{let X=q&127;if(!X)throw new J("tlv.decode(long): indefinite length not supported");if(X>4)throw new J("tlv.decode(long): byte length is too big");let A=G.subarray(Q,Q+X);if(A.length!==X)throw new J("tlv.decode: length bytes not complete");if(A[0]===0)throw new J("tlv.decode(long): zero leftmost byte");for(let Z of A)M=M<<8|Z;if(Q+=X,M<128)throw new J("tlv.decode(long): not minimal encoding")}let K=G.subarray(Q,Q+M);if(K.length!==M)throw new J("tlv.decode: wrong value length");return{v:K,l:G.subarray(Q+M)}}},_int:{encode($){let{Err:G}=G0;if($<n)throw new G("integer: negative integers are not allowed");let J=N0($);if(Number.parseInt(J[0],16)&8)J="00"+J;if(J.length&1)throw new G("unexpected DER parsing assertion: unpadded hex");return J},decode($){let{Err:G}=G0;if($[0]&128)throw new G("invalid signature integer: negative");if($[0]===0&&!($[1]&128))throw new G("invalid signature integer: unnecessary leading zero");return SJ($)}},toSig($){let{Err:G,_int:J,_tlv:Q}=G0,q=typeof $==="string"?kJ($):$;i(q);let{v:Y,l:M}=Q.decode(48,q);if(M.length)throw new G("invalid signature: left bytes after parsing");let{v:K,l:X}=Q.decode(2,Y),{v:A,l:Z}=Q.decode(2,X);if(Z.length)throw new G("invalid signature: left bytes after parsing");return{r:J.decode(K),s:J.decode(A)}},hexFromSig($){let{_tlv:G,_int:J}=G0,Q=G.encode(2,J.encode($.r)),q=G.encode(2,J.encode($.s)),Y=Q+q;return G.encode(48,Y)}},n=BigInt(0),w=BigInt(1),K0=BigInt(2),l0=BigInt(3),d$=BigInt(4);function xJ($){let G=RJ($),{Fp:J}=G,Q=u0(G.n,G.nBitLength),q=G.toBytes||((I,z,O)=>{let V=z.toAffine();return c(Uint8Array.from([4]),J.toBytes(V.x),J.toBytes(V.y))}),Y=G.fromBytes||((I)=>{let z=I.subarray(1),O=J.fromBytes(z.subarray(0,J.BYTES)),V=J.fromBytes(z.subarray(J.BYTES,2*J.BYTES));return{x:O,y:V}});function M(I){let{a:z,b:O}=G,V=J.sqr(I),C=J.mul(V,I);return J.add(J.add(C,J.mul(I,z)),O)}if(!J.eql(J.sqr(G.Gy),M(G.Gx)))throw new Error("bad generator point: equation left != right");function K(I){return M0(I,w,G.n)}function X(I){let{allowedPrivateKeyLengths:z,nByteLength:O,wrapPrivateKey:V,n:C}=G;if(z&&typeof I!=="bigint"){if(X0(I))I=j0(I);if(typeof I!=="string"||!z.includes(I.length))throw new Error("invalid private key");I=I.padStart(O*2,"0")}let L;try{L=typeof I==="bigint"?I:u(y("private key",I,O))}catch(k){throw new Error("invalid private key, expected hex or "+O+" bytes, got "+typeof I)}if(V)L=b(L,C);return e("private key",L,w,C),L}function A(I){if(!(I instanceof U))throw new Error("ProjectivePoint expected")}let Z=c0((I,z)=>{let{px:O,py:V,pz:C}=I;if(J.eql(C,J.ONE))return{x:O,y:V};let L=I.is0();if(z==null)z=L?J.ONE:J.inv(C);let k=J.mul(O,z),H=J.mul(V,z),R=J.mul(C,z);if(L)return{x:J.ZERO,y:J.ZERO};if(!J.eql(R,J.ONE))throw new Error("invZ was invalid");return{x:k,y:H}}),N=c0((I)=>{if(I.is0()){if(G.allowInfinityPoint&&!J.is0(I.py))return;throw new Error("bad point: ZERO")}let{x:z,y:O}=I.toAffine();if(!J.isValid(z)||!J.isValid(O))throw new Error("bad point: x or y not FE");let V=J.sqr(O),C=M(z);if(!J.eql(V,C))throw new Error("bad point: equation left != right");if(!I.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class U{constructor(I,z,O){if(this.px=I,this.py=z,this.pz=O,I==null||!J.isValid(I))throw new Error("x required");if(z==null||!J.isValid(z))throw new Error("y required");if(O==null||!J.isValid(O))throw new Error("z required");Object.freeze(this)}static fromAffine(I){let{x:z,y:O}=I||{};if(!I||!J.isValid(z)||!J.isValid(O))throw new Error("invalid affine point");if(I instanceof U)throw new Error("projective point not allowed");let V=(C)=>J.eql(C,J.ZERO);if(V(z)&&V(O))return U.ZERO;return new U(z,O,J.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(I){let z=J.invertBatch(I.map((O)=>O.pz));return I.map((O,V)=>O.toAffine(z[V])).map(U.fromAffine)}static fromHex(I){let z=U.fromAffine(Y(y("pointHex",I)));return z.assertValidity(),z}static fromPrivateKey(I){return U.BASE.multiply(X(I))}static msm(I,z){return h$(U,Q,I,z)}_setWindowSize(I){T.setWindowSize(this,I)}assertValidity(){N(this)}hasEvenY(){let{y:I}=this.toAffine();if(J.isOdd)return!J.isOdd(I);throw new Error("Field doesn't support isOdd")}equals(I){A(I);let{px:z,py:O,pz:V}=this,{px:C,py:L,pz:k}=I,H=J.eql(J.mul(z,k),J.mul(C,V)),R=J.eql(J.mul(O,k),J.mul(L,V));return H&&R}negate(){return new U(this.px,J.neg(this.py),this.pz)}double(){let{a:I,b:z}=G,O=J.mul(z,l0),{px:V,py:C,pz:L}=this,k=J.ZERO,H=J.ZERO,R=J.ZERO,B=J.mul(V,V),v=J.mul(C,C),f=J.mul(L,L),x=J.mul(V,C);return x=J.add(x,x),R=J.mul(V,L),R=J.add(R,R),k=J.mul(I,R),H=J.mul(O,f),H=J.add(k,H),k=J.sub(v,H),H=J.add(v,H),H=J.mul(k,H),k=J.mul(x,k),R=J.mul(O,R),f=J.mul(I,f),x=J.sub(B,f),x=J.mul(I,x),x=J.add(x,R),R=J.add(B,B),B=J.add(R,B),B=J.add(B,f),B=J.mul(B,x),H=J.add(H,B),f=J.mul(C,L),f=J.add(f,f),B=J.mul(f,x),k=J.sub(k,B),R=J.mul(f,v),R=J.add(R,R),R=J.add(R,R),new U(k,H,R)}add(I){A(I);let{px:z,py:O,pz:V}=this,{px:C,py:L,pz:k}=I,H=J.ZERO,R=J.ZERO,B=J.ZERO,v=G.a,f=J.mul(G.b,l0),x=J.mul(z,C),m=J.mul(O,L),l=J.mul(V,k),j=J.add(z,O),D=J.add(C,L);j=J.mul(j,D),D=J.add(x,m),j=J.sub(j,D),D=J.add(z,V);let S=J.add(C,k);return D=J.mul(D,S),S=J.add(x,l),D=J.sub(D,S),S=J.add(O,V),H=J.add(L,k),S=J.mul(S,H),H=J.add(m,l),S=J.sub(S,H),B=J.mul(v,D),H=J.mul(f,l),B=J.add(H,B),H=J.sub(m,B),B=J.add(m,B),R=J.mul(H,B),m=J.add(x,x),m=J.add(m,x),l=J.mul(v,l),D=J.mul(f,D),m=J.add(m,l),l=J.sub(x,l),l=J.mul(v,l),D=J.add(D,l),x=J.mul(m,D),R=J.add(R,x),x=J.mul(S,D),H=J.mul(j,H),H=J.sub(H,x),x=J.mul(j,m),B=J.mul(S,B),B=J.add(B,x),new U(H,R,B)}subtract(I){return this.add(I.negate())}is0(){return this.equals(U.ZERO)}wNAF(I){return T.wNAFCached(this,I,U.normalizeZ)}multiplyUnsafe(I){let{endo:z,n:O}=G;e("scalar",I,n,O);let V=U.ZERO;if(I===n)return V;if(this.is0()||I===w)return this;if(!z||T.hasPrecomputes(this))return T.wNAFCachedUnsafe(this,I,U.normalizeZ);let{k1neg:C,k1:L,k2neg:k,k2:H}=z.splitScalar(I),R=V,B=V,v=this;while(L>n||H>n){if(L&w)R=R.add(v);if(H&w)B=B.add(v);v=v.double(),L>>=w,H>>=w}if(C)R=R.negate();if(k)B=B.negate();return B=new U(J.mul(B.px,z.beta),B.py,B.pz),R.add(B)}multiply(I){let{endo:z,n:O}=G;e("scalar",I,w,O);let V,C;if(z){let{k1neg:L,k1:k,k2neg:H,k2:R}=z.splitScalar(I),{p:B,f:v}=this.wNAF(k),{p:f,f:x}=this.wNAF(R);B=T.constTimeNegate(L,B),f=T.constTimeNegate(H,f),f=new U(J.mul(f.px,z.beta),f.py,f.pz),V=B.add(f),C=v.add(x)}else{let{p:L,f:k}=this.wNAF(I);V=L,C=k}return U.normalizeZ([V,C])[0]}multiplyAndAddUnsafe(I,z,O){let V=U.BASE,C=(k,H)=>H===n||H===w||!k.equals(V)?k.multiplyUnsafe(H):k.multiply(H),L=C(this,z).add(C(I,O));return L.is0()?void 0:L}toAffine(I){return Z(this,I)}isTorsionFree(){let{h:I,isTorsionFree:z}=G;if(I===w)return!0;if(z)return z(U,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:I,clearCofactor:z}=G;if(I===w)return this;if(z)return z(U,this);return this.multiplyUnsafe(G.h)}toRawBytes(I=!0){return U0("isCompressed",I),this.assertValidity(),q(U,this,I)}toHex(I=!0){return U0("isCompressed",I),j0(this.toRawBytes(I))}}U.BASE=new U(G.Gx,G.Gy,J.ONE),U.ZERO=new U(J.ZERO,J.ONE,J.ZERO);let W=G.nBitLength,T=y$(U,G.endo?Math.ceil(W/2):W);return{CURVE:G,ProjectivePoint:U,normPrivateKeyToScalar:X,weierstrassEquation:M,isWithinCurveOrder:K}}function wJ($){let G=j$($);return $0(G,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...G})}function u$($){let G=wJ($),{Fp:J,n:Q}=G,q=J.BYTES+1,Y=2*J.BYTES+1;function M(j){return b(j,Q)}function K(j){return d0(j,Q)}let{ProjectivePoint:X,normPrivateKeyToScalar:A,weierstrassEquation:Z,isWithinCurveOrder:N}=xJ({...G,toBytes(j,D,S){let P=D.toAffine(),E=J.toBytes(P.x),_=c;if(U0("isCompressed",S),S)return _(Uint8Array.from([D.hasEvenY()?2:3]),E);else return _(Uint8Array.from([4]),E,J.toBytes(P.y))},fromBytes(j){let D=j.length,S=j[0],P=j.subarray(1);if(D===q&&(S===2||S===3)){let E=u(P);if(!M0(E,w,J.ORDER))throw new Error("Point is not on curve");let _=Z(E),o;try{o=J.sqrt(_)}catch(t){let F=t instanceof Error?": "+t.message:"";throw new Error("Point is not on curve"+F)}let d=(o&w)===w;if((S&1)===1!==d)o=J.neg(o);return{x:E,y:o}}else if(D===Y&&S===4){let E=J.fromBytes(P.subarray(0,J.BYTES)),_=J.fromBytes(P.subarray(J.BYTES,2*J.BYTES));return{x:E,y:_}}else{let E=q,_=Y;throw new Error("invalid Point, expected length of "+E+", or uncompressed "+_+", got "+D)}}}),U=(j)=>j0(p(j,G.nByteLength));function W(j){let D=Q>>w;return j>D}function T(j){return W(j)?M(-j):j}let I=(j,D,S)=>u(j.slice(D,S));class z{constructor(j,D,S){this.r=j,this.s=D,this.recovery=S,this.assertValidity()}static fromCompact(j){let D=G.nByteLength;return j=y("compactSignature",j,D*2),new z(I(j,0,D),I(j,D,2*D))}static fromDER(j){let{r:D,s:S}=G0.toSig(y("DER",j));return new z(D,S)}assertValidity(){e("r",this.r,w,Q),e("s",this.s,w,Q)}addRecoveryBit(j){return new z(this.r,this.s,j)}recoverPublicKey(j){let{r:D,s:S,recovery:P}=this,E=H(y("msgHash",j));if(P==null||![0,1,2,3].includes(P))throw new Error("recovery id invalid");let _=P===2||P===3?D+G.n:D;if(_>=J.ORDER)throw new Error("recovery id 2 or 3 invalid");let o=(P&1)===0?"02":"03",d=X.fromHex(o+U(_)),s=K(_),t=M(-E*s),F=M(S*s),Q0=X.BASE.multiplyAndAddUnsafe(d,t,F);if(!Q0)throw new Error("point at infinify");return Q0.assertValidity(),Q0}hasHighS(){return W(this.s)}normalizeS(){return this.hasHighS()?new z(this.r,M(-this.s),this.recovery):this}toDERRawBytes(){return V0(this.toDERHex())}toDERHex(){return G0.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return V0(this.toCompactHex())}toCompactHex(){return U(this.r)+U(this.s)}}let O={isValidPrivateKey(j){try{return A(j),!0}catch(D){return!1}},normPrivateKeyToScalar:A,randomPrivateKey:()=>{let j=I$(G.n);return _$(G.randomBytes(j),G.n)},precompute(j=8,D=X.BASE){return D._setWindowSize(j),D.multiply(BigInt(3)),D}};function V(j,D=!0){return X.fromPrivateKey(j).toRawBytes(D)}function C(j){let D=X0(j),S=typeof j==="string",P=(D||S)&&j.length;if(D)return P===q||P===Y;if(S)return P===2*q||P===2*Y;if(j instanceof X)return!0;return!1}function L(j,D,S=!0){if(C(j))throw new Error("first arg must be private key");if(!C(D))throw new Error("second arg must be public key");return X.fromHex(D).multiply(A(j)).toRawBytes(S)}let k=G.bits2int||function(j){if(j.length>8192)throw new Error("input is too large");let D=u(j),S=j.length*8-G.nBitLength;return S>0?D>>BigInt(S):D},H=G.bits2int_modN||function(j){return M(k(j))},R=S0(G.nBitLength);function B(j){return e("num < 2^"+G.nBitLength,j,n,R),p(j,G.nByteLength)}function v(j,D,S=f){if(["recovered","canonical"].some((Z0)=>(Z0 in S)))throw new Error("sign() legacy options not supported");let{hash:P,randomBytes:E}=G,{lowS:_,prehash:o,extraEntropy:d}=S;if(_==null)_=!0;if(j=y("msgHash",j),c$(S),o)j=y("prehashed msgHash",P(j));let s=H(j),t=A(D),F=[B(t),B(s)];if(d!=null&&d!==!1){let Z0=d===!0?E(J.BYTES):d;F.push(y("extraEntropy",Z0))}let Q0=c(...F),P0=s;function n0(Z0){let O0=k(Z0);if(!N(O0))return;let s0=K(O0),T0=X.BASE.multiply(O0).toAffine(),z0=M(T0.x);if(z0===n)return;let L0=M(s0*M(P0+z0*t));if(L0===n)return;let D0=(T0.x===z0?0:2)|Number(T0.y&w),C$=L0;if(_&&W(L0))C$=T(L0),D0^=1;return new z(z0,C$,D0)}return{seed:Q0,k2sig:n0}}let f={lowS:G.lowS,prehash:!1},x={lowS:G.lowS,prehash:!1};function m(j,D,S=f){let{seed:P,k2sig:E}=v(j,D,S),_=G;return Y$(_.hash.outputLen,_.nByteLength,_.hmac)(P,E)}X.BASE._setWindowSize(8);function l(j,D,S,P=x){let E=j;D=y("msgHash",D),S=y("publicKey",S);let{lowS:_,prehash:o,format:d}=P;if(c$(P),"strict"in P)throw new Error("options.strict was renamed to lowS");if(d!==void 0&&d!=="compact"&&d!=="der")throw new Error("format must be compact or der");let s=typeof E==="string"||X0(E),t=!s&&!d&&typeof E==="object"&&E!==null&&typeof E.r==="bigint"&&typeof E.s==="bigint";if(!s&&!t)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let F=void 0,Q0;try{if(t)F=new z(E.r,E.s);if(s){try{if(d!=="compact")F=z.fromDER(E)}catch(D0){if(!(D0 instanceof G0.Err))throw D0}if(!F&&d!=="der")F=z.fromCompact(E)}Q0=X.fromHex(S)}catch(D0){return!1}if(!F)return!1;if(_&&F.hasHighS())return!1;if(o)D=G.hash(D);let{r:P0,s:n0}=F,Z0=H(D),O0=K(n0),s0=M(Z0*O0),T0=M(P0*O0),z0=X.BASE.multiplyAndAddUnsafe(Q0,s0,T0)?.toAffine();if(!z0)return!1;return M(z0.x)===P0}return{CURVE:G,getPublicKey:V,getSharedSecret:L,sign:m,verify:l,ProjectivePoint:X,Signature:z,utils:O}}function EJ($,G){let J=$.ORDER,Q=n;for(let T=J-w;T%K0===n;T/=K0)Q+=w;let q=Q,Y=K0<<q-w-w,M=Y*K0,K=(J-w)/M,X=(K-w)/K0,A=M-w,Z=Y,N=$.pow(G,K),U=$.pow(G,(K+w)/K0),W=(T,I)=>{let z=N,O=$.pow(I,A),V=$.sqr(O);V=$.mul(V,I);let C=$.mul(T,V);C=$.pow(C,X),C=$.mul(C,O),O=$.mul(C,I),V=$.mul(C,T);let L=$.mul(V,O);C=$.pow(L,Z);let k=$.eql(C,$.ONE);O=$.mul(V,U),C=$.mul(L,z),V=$.cmov(O,V,k),L=$.cmov(C,L,k);for(let H=q;H>w;H--){let R=H-K0;R=K0<<R-w;let B=$.pow(L,R),v=$.eql(B,$.ONE);O=$.mul(V,z),z=$.mul(z,z),B=$.mul(L,z),V=$.cmov(O,V,v),L=$.cmov(B,L,v)}return{isValid:k,value:V}};if($.ORDER%d$===l0){let T=($.ORDER-l0)/d$,I=$.sqrt($.neg(G));W=(z,O)=>{let V=$.sqr(O),C=$.mul(z,O);V=$.mul(V,C);let L=$.pow(V,T);L=$.mul(L,C);let k=$.mul(L,I),H=$.mul($.sqr(L),O),R=$.eql(H,z),B=$.cmov(k,L,R);return{isValid:R,value:B}}}return W}function m$($,G){if(F0($),!$.isValid(G.A)||!$.isValid(G.B)||!$.isValid(G.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");let J=EJ($,G.Z);if(!$.isOdd)throw new Error("Fp.isOdd is not implemented!");return(Q)=>{let q,Y,M,K,X,A,Z,N;q=$.sqr(Q),q=$.mul(q,G.Z),Y=$.sqr(q),Y=$.add(Y,q),M=$.add(Y,$.ONE),M=$.mul(M,G.B),K=$.cmov(G.Z,$.neg(Y),!$.eql(Y,$.ZERO)),K=$.mul(K,G.A),Y=$.sqr(M),A=$.sqr(K),X=$.mul(A,G.A),Y=$.add(Y,X),Y=$.mul(Y,M),A=$.mul(A,K),X=$.mul(A,G.B),Y=$.add(Y,X),Z=$.mul(q,M);let{isValid:U,value:W}=J(Y,A);N=$.mul(q,Q),N=$.mul(N,W),Z=$.cmov(Z,M,U),N=$.cmov(N,W,U);let T=$.isOdd(Q)===$.isOdd(N);return N=$.cmov($.neg(N),N,T),Z=$.div(Z,K),{x:Z,y:N}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function PJ($){return{hash:$,hmac:(G,...J)=>$$($,G,l$(...J)),randomBytes:r0}}function r$($,G){let J=(Q)=>u$({...$,...PJ(Q)});return{...J(G),create:J}}var fJ=u;function I0($,G){if(k0($),k0(G),$<0||$>=1<<8*G)throw new Error("invalid I2OSP input: "+$);let J=Array.from({length:G}).fill(0);for(let Q=G-1;Q>=0;Q--)J[Q]=$&255,$>>>=8;return new Uint8Array(J)}function _J($,G){let J=new Uint8Array($.length);for(let Q=0;Q<$.length;Q++)J[Q]=$[Q]^G[Q];return J}function k0($){if(!Number.isSafeInteger($))throw new Error("number expected")}function gJ($,G,J,Q){if(i($),i(G),k0(J),G.length>255)G=Q(c(R0("H2C-OVERSIZE-DST-"),G));let{outputLen:q,blockLen:Y}=Q,M=Math.ceil(J/q);if(J>65535||M>255)throw new Error("expand_message_xmd: invalid lenInBytes");let K=c(G,I0(G.length,1)),X=I0(0,Y),A=I0(J,2),Z=new Array(M),N=Q(c(X,$,A,I0(0,1),K));Z[0]=Q(c(N,I0(1,1),K));for(let W=1;W<=M;W++){let T=[_J(N,Z[W-1]),I0(W+1,1),K];Z[W]=Q(c(...T))}return c(...Z).slice(0,J)}function bJ($,G,J,Q,q){if(i($),i(G),k0(J),G.length>255){let Y=Math.ceil(2*Q/8);G=q.create({dkLen:Y}).update(R0("H2C-OVERSIZE-DST-")).update(G).digest()}if(J>65535||G.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return q.create({dkLen:J}).update($).update(I0(J,2)).update(G).update(I0(G.length,1)).digest()}function o$($,G,J){$0(J,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});let{p:Q,k:q,m:Y,hash:M,expand:K,DST:X}=J;i($),k0(G);let A=typeof X==="string"?R0(X):X,Z=Q.toString(2).length,N=Math.ceil((Z+q)/8),U=G*Y*N,W;if(K==="xmd")W=gJ($,A,U,M);else if(K==="xof")W=bJ($,A,U,q,M);else if(K==="_internal_pass")W=$;else throw new Error('expand must be "xmd" or "xof"');let T=new Array(G);for(let I=0;I<G;I++){let z=new Array(Y);for(let O=0;O<Y;O++){let V=N*(O+I*Y),C=W.subarray(V,V+N);z[O]=b(fJ(C),Q)}T[I]=z}return T}function i$($,G){let J=G.map((Q)=>Array.from(Q).reverse());return(Q,q)=>{let[Y,M,K,X]=J.map((A)=>A.reduce((Z,N)=>$.add($.mul(Z,Q),N)));return Q=$.div(Y,M),q=$.mul(q,$.div(K,X)),{x:Q,y:q}}}function a$($,G,J){if(typeof G!=="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(Q,q){let Y=o$(Q,2,{...J,DST:J.DST,...q}),M=$.fromAffine(G(Y[0])),K=$.fromAffine(G(Y[1])),X=M.add(K).clearCofactor();return X.assertValidity(),X},encodeToCurve(Q,q){let Y=o$(Q,1,{...J,DST:J.encodeDST,...q}),M=$.fromAffine(G(Y[0])).clearCofactor();return M.assertValidity(),M},mapToCurve(Q){if(!Array.isArray(Q))throw new Error("mapToCurve: expected array of bigints");for(let Y of Q)if(typeof Y!=="bigint")throw new Error("mapToCurve: expected array of bigints");let q=$.fromAffine(G(Q)).clearCofactor();return q.assertValidity(),q}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */var E0=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),o0=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),x0=BigInt(1),i0=BigInt(2),p$=($,G)=>($+G/i0)/G;function s$($){let G=E0,J=BigInt(3),Q=BigInt(6),q=BigInt(11),Y=BigInt(22),M=BigInt(23),K=BigInt(44),X=BigInt(88),A=$*$*$%G,Z=A*A*$%G,N=r(Z,J,G)*Z%G,U=r(N,J,G)*Z%G,W=r(U,i0,G)*A%G,T=r(W,q,G)*W%G,I=r(T,Y,G)*T%G,z=r(I,K,G)*I%G,O=r(z,X,G)*z%G,V=r(O,K,G)*I%G,C=r(V,J,G)*Z%G,L=r(C,M,G)*T%G,k=r(L,Q,G)*A%G,H=r(k,i0,G);if(!A0.eql(A0.sqr(H),$))throw new Error("Cannot find square root");return H}var A0=u0(E0,void 0,void 0,{sqrt:s$}),p0=r$({a:BigInt(0),b:BigInt(7),Fp:A0,n:o0,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:($)=>{let G=o0,J=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),Q=-x0*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),q=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),Y=J,M=BigInt("0x100000000000000000000000000000000"),K=p$(Y*$,G),X=p$(-Q*$,G),A=b($-K*J-X*q,G),Z=b(-K*Q-X*Y,G),N=A>M,U=Z>M;if(N)A=G-A;if(U)Z=G-Z;if(A>M||Z>M)throw new Error("splitScalar: Endomorphism failed, k="+$);return{k1neg:N,k1:A,k2neg:U,k2:Z}}}},B0),t$=BigInt(0),n$={};function a0($,...G){let J=n$[$];if(J===void 0){let Q=B0(Uint8Array.from($,(q)=>q.charCodeAt(0)));J=c(Q,Q),n$[$]=J}return B0(c(J,...G))}var O$=($)=>$.toRawBytes(!0).slice(1),V$=($)=>p($,32),N$=($)=>b($,E0),w0=($)=>b($,o0),D$=p0.ProjectivePoint,vJ=($,G,J)=>D$.BASE.multiplyAndAddUnsafe($,G,J);function W$($){let G=p0.utils.normPrivateKeyToScalar($),J=D$.fromPrivateKey(G);return{scalar:J.hasEvenY()?G:w0(-G),bytes:O$(J)}}function e$($){e("x",$,x0,E0);let G=N$($*$),J=N$(G*$+BigInt(7)),Q=s$(J);if(Q%i0!==t$)Q=N$(-Q);let q=new D$($,Q,x0);return q.assertValidity(),q}var H0=u;function $J(...$){return w0(H0(a0("BIP0340/challenge",...$)))}function yJ($){return W$($).bytes}function hJ($,G,J=r0(32)){let Q=y("message",$),{bytes:q,scalar:Y}=W$(G),M=y("auxRand",J,32),K=V$(Y^H0(a0("BIP0340/aux",M))),X=a0("BIP0340/nonce",K,q,Q),A=w0(H0(X));if(A===t$)throw new Error("sign failed: k is zero");let{bytes:Z,scalar:N}=W$(A),U=$J(Z,q,Q),W=new Uint8Array(64);if(W.set(Z,0),W.set(V$(w0(N+U*Y)),32),!JJ(W,Q,q))throw new Error("sign: Invalid signature produced");return W}function JJ($,G,J){let Q=y("signature",$,64),q=y("message",G),Y=y("publicKey",J,32);try{let M=e$(H0(Y)),K=H0(Q.subarray(0,32));if(!M0(K,x0,E0))return!1;let X=H0(Q.subarray(32,64));if(!M0(X,x0,o0))return!1;let A=$J(V$(K),O$(M),q),Z=vJ(M,X,w0(-A));if(!Z||!Z.hasEvenY()||Z.toAffine().x!==K)return!1;return!0}catch(M){return!1}}var D8=(()=>({getPublicKey:yJ,sign:hJ,verify:JJ,utils:{randomPrivateKey:p0.utils.randomPrivateKey,lift_x:e$,pointToBytes:O$,numberToBytesBE:p,bytesToNumberBE:u,taggedHash:a0,mod:b}}))(),cJ=(()=>i$(A0,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(($)=>$.map((G)=>BigInt(G)))))(),dJ=(()=>m$(A0,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:A0.create(BigInt("-11"))}))(),GJ=(()=>a$(p0.ProjectivePoint,($)=>{let{x:G,y:J}=dJ(A0.create($[0]));return cJ(G,J)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:A0.ORDER,m:1,k:128,expand:"xmd",hash:B0}))(),C8=(()=>GJ.hashToCurve)(),H8=(()=>GJ.encodeToCurve)();export{p0 as secp256k1,D8 as schnorr,C8 as hashToCurve,H8 as encodeToCurve};
export{B0 as G,p0 as H};
